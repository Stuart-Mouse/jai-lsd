#import "Print_Vars";

// used to build a DOM from a text file and evaluate data bindings on that DOM
Parser :: struct {
    using #as script: Script;
    
    // #place script.ast_root;
    dom_root: *Node_Field;
    
    #place current_scope;
        current_parent: *Node_Field;
};

init_parser :: (parser: *Parser, file: string, file_path := "") {
    init_script(*parser.script);
    
    array_add(*parser.operator_table,
        .{ .PREFIX, "&",  8, "" },
        .{ .PREFIX, "*",  8, "" },
        .{ .PREFIX, "$",  8, "" },
    );
    
    parser.my_parse_leaf     = my_parse_leaf;
    parser.my_parse_binary   = my_parse_binary;
    parser.my_typecheck_node = xx my_typecheck_node;
    parser.my_evaluate_node  = my_evaluate_node;
    
    register_common_types(*parser.script);
    
    init_lexer(parser, file, location = .{ file_path, 1, 1 });
    
    parser.dom_root       = alloc_node(parser, Node_Field);
    parser.current_parent = parser.dom_root;
    parser.dom_root.value = alloc_node(parser, Node_Object);
}

deinit_parser :: (parser: *Parser) {
    deinit_script(*parser.script);
}

// creates a dom parser with the given parameters, intializes it, and constructs the dom from the given file
// after calling this, you can just add your data bindings and then process them
parse_file_to_dom :: (file: string, filepath := "") -> (Parser, bool) {
    parser: Parser;
    init_parser(*parser, file, filepath);
    if !construct_dom_from_file(*parser)  return parser, false;
    return parser, true;
}

add_data_binding_to_dom :: (parser: *Parser, binding: Any, path: string) -> bool {
    node := find_node_by_path(parser.dom_root, path);
    return add_data_binding_to_node(parser, node, binding);
}

add_data_bindings_to_dom :: (parser: *Parser, bindings: [] struct { binding: Any; path: string; }) -> bool {
    for bindings
        if !add_data_binding_to_dom(parser, it.binding, it.path)  
            return false;
    return true;
}

process_data_bindings :: (parser: *Parser) -> bool {
    fields := get_fields(parser.dom_root);
    for fields {
        if !parser.my_typecheck_node(parser, it)  return false;
    }
    for fields {
        parser.my_evaluate_node(parser, it);
        if has_error(parser)  return false;
    }
    return true;
}

construct_dom_from_file :: (using parser: *Parser) -> bool {
    while !expect_token_type(*script, .EOF) {
        field := parse_field(parser, true);
        if !field  return false;
        append_child_node(parser, dom_root.value.(*Node_Object), field);
    }
    return true;
}

get_io_data_name :: (any: Any) -> bool, string {
    io_data := get_io_data(any.type);
    if !io_data || !io_data.name_member  return false, "";
    
    name_member_any := get_member(any, io_data.name_member);
    
    name: string;
    return Convert.any_to_any(name, name_member_any), name;
}

add_data_binding_to_node :: (parser: *Parser, node: *Node_Field, binding: Any) -> bool  {
    if node == null || binding.value_pointer == null  return true;
    
    if node.binding.value_pointer != null {
        set_typecheck_error(parser, "node already has data binding set", node = node);
        return false;
    }
    node.binding = binding;
    
    name_member: *Type_Info_Struct_Member;
    name_member_any: Any;
    
    io_data := get_io_data(node.binding.type);
    if io_data {
        // because we may rebind the node, we need to assign the name_member_any
        // if this Any is still set after making bindings to child nodes, then we will assign to it
        if io_data.name_member {
            name_member = io_data.name_member;
            name_member_any = Any.{ name_member.type, node.binding.value_pointer + name_member.offset_in_bytes };
        }
        
        if io_data.bind_proc {
            node.binding = io_data.bind_proc(node.binding);
            if node.binding.value_pointer == null {
                set_typecheck_error(parser, "io_data.bind_proc returned null", node = node);
                return false;
            }
            // get new io data for new binding
            io_data = get_io_data(node.binding.type);
        }
    }
    
    defer if name_member {
        name_member_io_data := get_io_data(name_member_any.type);
        if name_member_io_data && name_member_io_data.parse_proc {
            return name_member_io_data.parse_proc(name_member_any, node.name);
        } else {
            return Convert.any_to_any(name_member_any, node.name);
        }
    }
    
    // TODO: think about whether we want to reimplement this functionality
    //       user could probably handle this in bind proc, or we could add some flag to io data
    // node.binding = deref_any_pointer(node.binding);
    
    // make indirect bindings onto child nodes
    if node.value.node_type == {
      case Node_Object;
        node_object := node.value.(*Node_Object);
        if node.binding.type.type == {
          case .STRUCT;
            for node_object.fields {
                member := get_field(xx node.binding.type, it.name);
                if !member || member.flags & .CONSTANT  continue;
                
                // we don't want to set it if the name member has a binding to a child node
                if member == name_member then name_member = null;
                
                member_any := Any.{ member.type, node.binding.value_pointer + member.offset_in_bytes };
                if !add_data_binding_to_node(parser, it, member_any)  return false;
            }
            
            // we don't want to set the name member if the parent exists and is an indexed array, because then the gon name is being used for the index
            if node.parent && has_flag(node.parent.field_flags, .IS_INDEXED_ARRAY) then name_member = null;
            
            
          case .ARRAY;
            array := Any_Array.from(node.binding);
            
            if io_data && has_flag(io_data.flags, .IS_INDEXED_ARRAY) {
                node.field_flags |= .IS_INDEXED_ARRAY;
            }
            
            element_io_data := get_io_data(array.element_type);
            
            is_valid_binding := has_flag(node.field_flags, .IS_INDEXED_ARRAY);
            if !is_valid_binding && array.element_type.type == .STRUCT {
                // TODO: find out why the below logic is causing issues. I think it should be correct
                // print_vars(array.element_type, element_io_data);
                // if element_io_data  print_vars(element_io_data.*);
                is_valid_binding ||= element_io_data != null && element_io_data.name_member != null;
            }
            
            if !is_valid_binding {
                set_typecheck_error(parser, "Object with binding to array type must be indexed or contain a struct type with a name member defined in io_data. Element type was %", as_type(array.element_type), node = node);
                return false;
            }
            
            if has_flag(node.field_flags, .IS_INDEXED_ARRAY) {
                min_index, max_index := S64_MAX, S64_MIN;
                if io_data.enum_index_type {
                    for node_object.fields {
                        index, ok := enum_name_to_value(xx io_data.enum_index_type, it.name);
                        if !ok {
                            set_typecheck_error(parser, "Unable to parse enum value from string: %", it.name, node = node);
                            return false;
                        }
                        min_index = min(min_index, index);
                        max_index = max(max_index, index);
                    }
                } else {
                    for node_object.fields {
                        index, ok, remainder := to_integer(it.name);
                        if !ok || remainder {
                            set_typecheck_error(parser, "Unable to parse integer from string: %", it.name, node = node);
                            return false;
                        }
                        min_index = min(min_index, index);
                        max_index = max(max_index, index);
                    }
                }
                
                // TODO: add a configurable absolute max index so that we don't resize to some insane amount.
                // TODO: maybe move this check for negative indices into above loops?
                if min_index < 0 || max_index < 0 {
                    set_typecheck_error(parser, "Invalid array index: %, index cannot be negative", min_index, node = node);
                    return false;
                }
                if array.array_type == {
                  case .RESIZABLE;
                    resize(array, max_index, true);
                    
                  case .FIXED; #through;
                  case .VIEW;
                    count, data := get_count_and_data(array);
                    if data {
                        if node_object.fields.count > count {
                            set_typecheck_error(parser, "Bounds check failed on fixed array or view. Object contains % elements, but array only contains space for % elements.", node_object.fields.count, count, node = node);
                            return false;
                        }
                    } else if array.array_type == .VIEW {
                        assert(count == 0);
                        resize(array, max_index, true);
                    }
                }
                
                if io_data.enum_index_type {
                    for node_object.fields {
                        index := enum_name_to_value(xx io_data.enum_index_type, it.name);
                        if !add_data_binding_to_node(parser, it, array[index])  return false;
                    }
                } else {
                    for node_object.fields {
                        index := to_integer(it.name);
                        if !add_data_binding_to_node(parser, it, array[index])  return false;
                    }
                }
            } else {
                count, data := get_count_and_data(array);
                
                // NOTE: we apply an offset to the index used for child bindings when we are 
                //       dealing with a resizable array which already contains some elements
                index_offset := 0;  
                
                if array.array_type == {
                  case .RESIZABLE;
                    resize(array, count + node_object.fields.count, true);
                    index_offset = count;
                    
                  case .FIXED; #through;
                  case .VIEW;
                    if data {
                        if node_object.fields.count > count {
                            set_typecheck_error(parser, "Bounds check failed on fixed array or view. Object contains % elements, but array only contains space for % elements.", node_object.fields.count, count, node = node);
                            return false;
                        }
                    } else if array.array_type == .VIEW {
                        assert(count == 0);
                        resize(array, node_object.fields.count, true);
                    }
                }
                for node_object.fields {
                    if !add_data_binding_to_node(parser, it, array[index_offset + it_index])  return false;
                }
            }
            
          case;
            set_typecheck_error(parser, "Cannot bind value of type % to %", as_type(node.binding.type), node_object.node_type, node = node);
            return false;
        }
        
        
      case Node_Array;
        node_array := node.value.(*Node_Array);
        if node.binding.type.type == {
          case .STRUCT;
            struct_info := node.binding.type.(*Type_Info_Struct);
            
            // TODO: should count only assignable members, not all members
            if node_array.fields.count > struct_info.members.count {
                set_typecheck_error(parser, "Incorrect number of fields provided sor struct. Array contains % elements, but struct only contains % elements.", node_array.fields.count, struct_info.members.count, node = node);
                return false;
            }
            
            last_member_offset := -1;
            for node_array.fields {
                member := struct_info.members[it_index];
                if member.flags & .CONSTANT  break;
                if member.offset_in_bytes < last_member_offset  break;
                last_member_offset = member.offset_in_bytes;
                
                member_any := Any.{ member.type, node.binding.value_pointer + member.offset_in_bytes };
                if !add_data_binding_to_node(parser, it, member_any)  return false;
            }
            
          case .ARRAY;
            array := Any_Array.from(node.binding);
            count, data := get_count_and_data(array);
            index_offset: int; // for dynamic array case, where we want to leave the existing items untouched
            
            if array.array_type == {
              case .RESIZABLE;
                /*
                    IMPORTANT NOTE: 
                    It is critical that the proper amount of space is pre-allocated for the dynamic array 
                    and that we don't have to realloc when we make data bindings for elements below.
                    Because if we realloc then that invalidates the pointers in the data bindings that we created
                    for all previous elements, since those are now pointing to the old locations of each element.
                */
                resize(Any_Array.from(node.binding), count + node_array.fields.count, true);
                index_offset = count;
                
              case .VIEW;
                if data == null {
                    assert(count == 0);
                    resize(array, node_array.fields.count);
                    count = node_array.fields.count; // @HACK: doing this because we read count in the .FIXED case below
                }
                #through;
                
              case .FIXED;
                if node_array.fields.count > count {
                    set_typecheck_error(parser, "Bounds check failed on fixed array or view. Array literal contains % elements, but underlying array only contains space for % elements.", node_array.fields.count, count, node = node);
                    return false;
                }
            }
            
            count, data = get_count_and_data(array);
            for node_array.fields {
                if !add_data_binding_to_node(parser, it, array[index_offset + it_index])  return false;
            }
            
          case;
            set_typecheck_error(parser, "Cannot bind value of type % to %", as_type(node.binding.type), node_array.node_type, node = node);
            return false;
        }
    }
    
    return true;
}

// NOTE: Since fields all store their own bindings, we have no need to use the standard hint_storage mechanism for fields and objects.
my_evaluate_node :: (script: *Script, node: *Node, provided_storage: *void = null, flags := Execution_Flags.NONE) -> Any {
    // log("evaluating % @ %", node.node_type, node);
    // log("provided_storage: %", provided_storage);
    // if node.node_type == Node_Field { 
    //     log("field: %", node.(*Node_Field).name);
    //     log("binding: %, %", as_type(node.(*Node_Field).binding.type), node.(*Node_Field).binding.value_pointer);
    // }
    
    return_result :: (node: *Node, any: Any) -> bool #expand {
        if provided_storage {
            // log("copying Any.{ %, % } for node % -> provided storage %", as_type(any.type), any.value_pointer, node, provided_storage);
            memcpy(provided_storage, any.value_pointer, any.type.runtime_size);
            `return Any.{ node.value_type, provided_storage };
        }
        result := push(*script.stack, any.value_pointer, any.type.runtime_size, should_push_by_pointer(node));
        if !result  set_execution_error(script, "Ran out of space on stack!", node = node);
        `return result;
    }
    
    if node.node_type == {
      case Node_Reference;
        reference := node.(*Node_Reference).*;
        
        if reference.reference_type == {
          case .VALUE;
            evaluate_node_or_return(script, reference.resolved_field);
            
            resolved_value := reference.resolved_field.binding;
            if resolved_value.type.type == .ANY {
                resolved_value = any_isa(resolved_value, Any).*;
            }
            return_result(node, resolved_value);
            
          case .INDEX; 
            return_result(node, to_any(*reference.resolved_field_index));
        }
        assert(false, "Unhandled reference type.");
        
        
        // NOTE: Node_Field does not itself push anything, it's more like an assignment statement or declaration in that sense
      case Node_Field;
        assert(provided_storage == null);
        field := node.(*Node_Field);
                
        if field.field_flags & .EVALUATED  return VOID_ANY;
        defer field.field_flags |= .EVALUATED;
        
        if field.binding.type == null {
            // set_execution_error(script, "field.binding.type was null", node = node);
            return VOID_ANY;
        }
        if field.binding.value_pointer == null {
            // set_execution_error(script, "field.binding.value_pointer was null", node = node);
            return VOID_ANY;
        }
        
        // NOTE: can only use a parse proc when the value type is string
        io_data := get_io_data(field.binding.type);
        if io_data && io_data.parse_proc && field.value.value_type == xx string {
            temp_string: string;
            evaluate_node_or_return(script, field.value, *temp_string);
            
            if !io_data.parse_proc(field.binding, temp_string) {
                set_execution_error(script, "io_data.parse_proc returned false for field '%' with value '%'.", field.name, temp_string, node = node);
                return NULL_ANY;
            }
            return VOID_ANY;
        }
        
        binding := field.binding;
        if field.binding.type.type == .ANY {
            any_ptr := any_isa(field.binding, Any);
            any_ptr.* = New_Any(field.value.value_type);
            binding = any_ptr.*;
        }
        
        evaluate_node_or_return(script, field.value, binding.value_pointer);
        if binding.type.type == .STRING {
            any_isa(binding, string).* = copy_string(any_isa(binding, string).*);
        }
        return VOID_ANY;
        
        
      case Node_Array; #through;
      case Node_Object;
        assert(node.scope.node_type == Node_Field, "%, %", node.scope.node_type, node.scope == script.ast_root);
        object := node.(*Node_Object);
        for object.fields  evaluate_node_or_return(script, it);
        
        return_result(object, object.parent.binding);
    }
    
    // the node wasn't any of our special types, so default to the standard evaluate_node
    return evaluate_node(script, node, provided_storage, flags);
}

my_typecheck_node :: (
    parser:         *Parser,
    node:           *Node, 
    check_flags:    Typechecking_Flags = .NONE,
    hint_type:      *Type_Info         = null
) -> (
    value_type:     *Type_Info
) {
    if node.node_type == {
      case Node_Field;
        field := node.(*Node_Field);
        
        // we set value_type for the sake of typechecking, but Node_Field does not actually return any value when executed.
        field.flags |= .VALUE_TYPE_IS_NOMINAL;
        
        if field.binding.type == null {
            field.value_type = type_info(void);
            return field.value_type;
        }
        
        // TODO: could create cyclic dependency error type and just check this error type to print all pending nodes on the way back up the call stack
        // We set the PENDING_DEPENDENCY flag on this node only for the duration of this call
        //      so that we know if we visit it again, we have gone in a loop.
        // TODO: would be better if we explicitly track the dependency chain so that we can print a better error here
        if field.field_flags & .PENDING_TYPECHECK {
            set_general_error(parser, "Cyclic dependency on node '%'.", format_node_path(field,, temp), loc = node.location);
            return null;
        }
        field.field_flags |= .PENDING_TYPECHECK;
        defer field.field_flags &= ~.PENDING_TYPECHECK;
        
        defer_restore(*parser.current_parent);
        parser.current_parent = field;
        
        value_type := parser.my_typecheck_node(parser, field.value, hint_type = field.binding.type);
        if !value_type  return null;
        
        // NOTE: if an io data parse proc is present, then the value_type of the RHS can always be a string
        //       this will not affect the value type of the field itself, which will still just be the binding's type
        io_data := get_io_data(field.binding.type);
        can_use_io_data_parse_proc := io_data != null && io_data.parse_proc != null && value_type == xx string;
        
        if field.binding.type.type != .ANY 
        && field.binding.type != value_type 
        && !can_use_io_data_parse_proc {
            set_general_error(parser, "Mismatched types on field binding and value expression. Expected %, got %.", as_type(field.binding.type), as_type(value_type), loc = node.location);
            return null;
        }
        
        field.value_type = field.binding.type;
        return field.value_type;
        
        
      case Node_Object;
        object := node.(*Node_Object);
        
        if hint_type == null {
            set_typecheck_error(parser, "Missing type hint on Node_Object.", node = node, type = .MISSING_TYPE_HINT, loc = node.location);
            return null;
        }
        object.value_type = hint_type;
        for object.fields {
            if !parser.my_typecheck_node(parser, it)  return null;
        }
        return object.value_type;
        
        
      case Node_Array;
        array := node.(*Node_Array);
        
        if hint_type == null {
            set_typecheck_error(parser, "Missing type hint on Node_Array.", node = node, type = .MISSING_TYPE_HINT, loc = node.location);
            return null;
        }
        array.value_type = hint_type;
        for array.fields {
            if !parser.my_typecheck_node(parser, it)  return null;
        }
        return array.value_type;
        
        
      case Node_Reference;
        reference := node.(*Node_Reference);
        field := parser.current_parent.(*Node_Field);
        
        resolved_field, resolved_index := find_node_by_path(xx parser, field.parent, reference.field_path);
        if resolved_field == null {
            set_typecheck_error(parser, "Unable to resolve referenced node path '%'.", reference.field_path, node = node, loc = node.location);
            return null; 
        }
        reference.resolved_field = resolved_field;
        reference.resolved_field_index = Any_Number.from(resolved_index);
        
        if reference.resolved_field.binding.value_pointer == null {
            // TODO: handle this case by creating temporary instance of hinted type?
            set_general_error(parser, "Referenced node '%' had no data binding!.", reference.field_path, loc = reference.location);
            return null;
        }
        
        // jump to referenced node
        if !parser.my_typecheck_node(parser, reference.resolved_field)  return null;
        
        if reference.reference_type == {
          case .VALUE; reference.value_type = reference.resolved_field.binding.type;
          case .INDEX; 
            reference.value_type = type_info(int);
            if hint_type {
                reference.value_type = hint_type;
                // convert reference.resolved_field_index to the hinted type and store back into same place
                Convert.any_to_any(Any.{ reference.value_type, *reference.resolved_field_index.value }, to_any(*reference.resolved_field_index));
            }
        }
        return reference.value_type;
    }
    
    // defer to default typecheck_node if it wasn't one out our special node types
    return typecheck_node(parser, node, check_flags, hint_type);
}


make_reference :: (script: *Script, type: Reference_Type, path: string) -> *Node_Reference {
    ref := alloc_node(script, Node_Reference);
    ref.reference_type = type;
    ref.field_path     = path;
    return ref;
}

// Custom versions of parse_leaf and parse_binary are implemented here to remove some of the LS features which we do not want to use in LSD.

my_parse_leaf :: (using script: *Script) -> *Node {
    token := get_token(script);
    
    is_operator, operator_index := get_prefix_operator(script, token);
    if is_operator {
        _operator := get_operator(script, operator_index);
        // special cases, bit of a parsing hack for the field reference operators
        // maybe later we will add the ability to have comptime operators more generally
        if token.text == {
          case "$";
            string_token := get_token(script);
            if string_token.type != .STRING {
                set_parse_error(script, "Expected a path string after node reference operator.", loc = token.location);
                return null;
            }
            return make_reference(script, .VALUE, string_token.text);
            
          case "&";
            string_token := get_token(script);
            if string_token.type != .STRING {
                set_parse_error(script, "Expected a path string after node reference operator.", loc = token.location);
                return null;
            }
            return make_reference(script, .INDEX, string_token.text);
        }
        
        left := my_parse_expression(script, _operator.precedence);
        if left == null  return null;
        return make_operation(script, token, operator_index, left, null);
    }
    
    if token.type == {
      case .DOT;
        token_after_dot := get_token(script);
        if token_after_dot.type == .IDENTIFIER {
            identifier := make_identifier(script, token_after_dot);
            return make_dot(script, token, null, identifier);
        } else {
            set_parse_error(script, "Unexpected % token '%' after unary dot.", token_after_dot.type, token_after_dot.text, loc = token_after_dot.location);
            return null;
        }
        
      case .OPEN_PAREN;
        open_paren_location := token.location;
        
        expression := my_parse_expression(script, 0);
        if expression == null  return null;
        expression.flags |= .PARENTHESIZED;
        
        close_paren_token := get_token(script);
        if close_paren_token.type != .CLOSE_PAREN {
            set_parse_error(script, "Expected a closing paren for open paren at %.", open_paren_location, loc = close_paren_token.location);
            return null;
        }
        return expression;
        
      case .OPEN_BRACE;
        object := alloc_node(script, Node_Object, loc = token.location);
        object.(*Node_Object).parent = xx script.current_scope;
        assert(script.current_scope.node_type == Node_Field);
        if !parse_object_contents(xx script, object)  return null;
        return object;
        
      case .OPEN_BRACKET;
        array := alloc_node(script, Node_Array, loc = token.location);
        array.(*Node_Array).parent = xx script.current_scope;
        assert(script.current_scope.node_type == Node_Field);
        if !parse_array_contents(xx script, array)  return null;
        return array;
        
      case .TRUE;
        literal := alloc_node(script, Node_Literal, loc = token.location, trivia = token.trivia);
        literal.literal_type = .BOOLEAN;
        literal.number       = to_any_number(true);
        return literal;
        
      case .FALSE;
        literal := alloc_node(script, Node_Literal, loc = token.location, trivia = token.trivia);
        literal.literal_type = .BOOLEAN;
        literal.number       = to_any_number(false);
        return literal;
        
      case .NUMBER;
        return make_number_literal(script, token);
        
      case .STRING;
        return make_string_literal(script, token);
        
      case .IDENTIFIER;
        return make_identifier(script, token);
        
      case .DIRECTIVE;
        directive := alloc_node(script, Node_Directive, loc = token.location, trivia = token.trivia);
        directive.name = token.text;
        
        directive.directive_index = -1;
        for script.directives {
            if it.name == directive.name {
                directive.directive_index = it_index;
            }
        }
        if directive.directive_index == -1 {
            set_parse_error(script, "Unable to resolve directive '%'\n", directive.name, loc = directive.location);
            return null;
        }
        
        open_paren_token := get_token(script);
        if open_paren_token.type != .OPEN_PAREN {
            set_parse_error(script, "Expected an open paren after directive name!\n", loc = open_paren_token.location);
            return null;
        }
        
        if !expect_token_type(script, .CLOSE_PAREN) {
            expressions := parse_comma_separated_expressions(script,, temp);
            if !expressions  return null;
            directive.arguments = array_copy(expressions,, LS.get_pool_allocator(*script.pool));
            
            close_paren_token := get_token(script);
            if close_paren_token.type != .CLOSE_PAREN {
                set_parse_error(script, "Expected a closing paren after arguments of directive. Instead we saw %\n", close_paren_token.text, loc = close_paren_token.location);
                return null;
            }
        }
        
        if !evaluate_directive(script, directive, .PARSE) {
            set_parse_error(script, "Failed while trying to execute a directive during parsing.", loc = token.location);
            return null;
        }
        return directive;
    }
    
    return null;
}

my_parse_binary :: (using script: *Script, left: *Node, min_prec: int) -> *Node {
    token := peek_token(script);
    
    // In addition to normal binary operators, we have a few binary-operator-like constructs that have essentially infinite operator precedence.
    // These are open parenthesis for procedure calls, dot for struct member access and cast, and open bracket for array indexing.
    if token.type == {
      case .OPEN_PAREN;
        get_token(script);
        arg_exprs, ok := parse_procedure_arguments(script);
        if !ok  return null;
        return make_procedure_call(script, token, left, arg_exprs);
        
        
      case .DOT;
        dot_token := get_token(script);
        
        token_after_dot := get_token(script);
        if token_after_dot.type == {
          case .OPEN_PAREN;
            type_expr := my_parse_expression(script, 0);
            close_paren := get_token(script);
            if close_paren.type != .CLOSE_PAREN {
                set_parse_error(script, "Unexpected token '%' in cast type expression. Expected a closing paren.", close_paren.type, loc = close_paren.location);
                return null;
            }
            return make_cast(script, dot_token, left, type_expr);
            
          case .IDENTIFIER;
            identifier := make_identifier(script, token_after_dot);
            return make_dot(script, dot_token, left, identifier);
        }
        
        set_parse_error(script, "Unexpected % token '%' after dot.", token.type, token.text, loc = token.location);
        return null;
        
        
      case .OPEN_BRACKET;
        open_bracket_token := get_token(script);
        
        indexing_expr := my_parse_expression(script, 0);
        if indexing_expr == null  return null;
        if !expect_token_type(script, .CLOSE_BRACKET)  return null;
        
        return make_subscript(script, open_bracket_token, left, indexing_expr);
    }
    
    // We only consume the binary operator here if it is of a higher precedence than the previous binary operator.
    // If we hit a binary operator but its precedence is too low, we return left back to caller.
    is_operator, operator_index := get_binary_operator(script, token);
    if is_operator {
        _operator := get_operator(script, operator_index);
        if _operator.precedence <= min_prec  return left;
        
        operator_token := get_token(script);
        right := my_parse_expression(script, _operator.precedence);
        if right == null  return null;
        
        return make_operation(script, operator_token, operator_index, left, right);
    }
    
    return left;
}

parse_field :: (parser: *Parser, parent_is_object: bool) -> *Node_Field {
    node := alloc_node(parser, Node_Field);
    node.parent = parser.current_parent;
    parser.current_parent = node;
    
    if parent_is_object {
        name_token := get_token(parser);
        node.location = name_token.location;
        
        if name_token.type == {
          case .IDENTIFIER; #through;
          case .STRING;
            node.name   = name_token.text;
            node.trivia = name_token.trivia;
            
            next_token := get_token(parser);
            if next_token.type != .COLON {
                set_parse_error(parser, "Expected colon after field name '%', got % \"%\"", name_token.text, next_token.type, next_token.text, node = node);
                return null;
            }
            
          case;
            set_parse_error(parser, "Expected a field name, but saw this instead: % (%)", name_token.text, name_token.type, node = node);
            return null;
        }
    }
    
    node.value = parser.my_parse_expression(parser, 0);
    
    if node.value == null {
        log("LSD parse error: failed to parse expression @ %", node.location);
        log(format_error(parser));
        return null;
    }
    // assert(node.value != null, "%: Node value was null, but no script error was set.", LS.get_location(node));
    
    if !parent_is_object {
        node.location = node.value.location;
    }
    
    next_token := peek_token(parser);
    if next_token.type == {
      case .CLOSE_BRACE;
      case .CLOSE_BRACKET;
      case .EOF;
      case .COMMA; get_token(parser);
      case;
        set_parse_error(parser, "Unexpected % token, expected end of scope or expression delimiter.", next_token.type, node = node);
        return null;
    }
    
    parser.current_parent = node.parent;
    return node;
}

parse_array_contents :: (using parser: *Parser, array: *Node_Array) -> bool {
    while !expect_token_type(*script, .CLOSE_BRACKET) {
        field := parse_field(parser, false);
        if !field  return false;
        append_child_node(parser, array, field);
    }
    return true;
}

parse_object_contents :: (using parser: *Parser, object: *Node_Object) -> bool {
    while !expect_token_type(*script, .CLOSE_BRACE) {
        field := parse_field(parser, true);
        if !field  return false;
        append_child_node(parser, object, field);
    }
    return true;
}
